/**
 * Supabase Notification Module
 * ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ ì‹œ ì•Œë¦¼ ì „ì†¡
 */

/**
 * ë³´ê³ ì„œ ë©”íƒ€ë°ì´í„° íƒ€ì…
 */
export interface ReportMetadata {
  incident_id: string;
  report_type: 'single' | 'multiple' | 'weekly' | 'monthly';
  report_path: string;
  risk_score?: number;
  verdict?: string;
  generated_at: string;
  generated_by: 'claude-code' | 'cli' | 'cron';
  incident_count?: number;
}

/**
 * Supabaseì— ë³´ê³ ì„œ ë©”íƒ€ë°ì´í„° ì €ì¥
 */
export async function notifyReportGenerated(metadata: ReportMetadata): Promise<void> {
  try {
    console.log(`[Supabase] ğŸ“¢ Sending notification for report: ${metadata.report_path}`);

    // Supabase URLì´ ì„¤ì •ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ê±´ë„ˆë›°ê¸°
    const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_ANON_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseKey) {
      console.log(`[Supabase] â­ï¸  Supabase not configured, skipping notification`);
      return;
    }

    // Supabase í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (ë™ì  import)
    const { createClient } = await import('@supabase/supabase-js');
    const supabase = createClient(supabaseUrl, supabaseKey);

    // ë³´ê³ ì„œ ë©”íƒ€ë°ì´í„° ì €ì¥
    const { data, error } = await supabase
      .from('incident_reports')
      .insert({
        incident_id: metadata.incident_id,
        report_type: metadata.report_type,
        report_path: metadata.report_path,
        risk_score: metadata.risk_score,
        verdict: metadata.verdict,
        generated_at: metadata.generated_at,
        generated_by: metadata.generated_by,
        incident_count: metadata.incident_count,
        status: 'completed',
      })
      .select();

    if (error) {
      console.error(`[Supabase] âŒ Failed to insert report metadata:`, error);
      return;
    }

    console.log(`[Supabase] âœ… Notification sent successfully`);

    // ì„ íƒì : ì›¹í›… í˜¸ì¶œ
    await sendWebhookNotification(metadata);

  } catch (error) {
    console.error(`[Supabase] âŒ Notification error:`, error);
  }
}

/**
 * ì›¹í›…ìœ¼ë¡œ ì•Œë¦¼ ì „ì†¡ (ì„ íƒì )
 */
async function sendWebhookNotification(metadata: ReportMetadata): Promise<void> {
  try {
    const webhookUrl = process.env.REPORT_WEBHOOK_URL;

    if (!webhookUrl) {
      return;
    }

    console.log(`[Webhook] ğŸ“¢ Sending webhook notification...`);

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        type: 'incident_report_generated',
        data: metadata,
        timestamp: new Date().toISOString(),
      }),
    });

    if (!response.ok) {
      console.error(`[Webhook] âŒ Failed to send webhook: ${response.status}`);
      return;
    }

    console.log(`[Webhook] âœ… Webhook sent successfully`);

  } catch (error) {
    console.error(`[Webhook] âŒ Webhook error:`, error);
  }
}

/**
 * Slack ì•Œë¦¼ ì „ì†¡ (ì„ íƒì )
 */
export async function sendSlackNotification(
  incidentId: string,
  reportPath: string,
  verdict?: string,
  riskScore?: number
): Promise<void> {
  try {
    const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;

    if (!slackWebhookUrl) {
      return;
    }

    console.log(`[Slack] ğŸ“¢ Sending Slack notification...`);

    const verdictEmoji = verdict === 'TRUE_POSITIVE' ? 'ğŸš¨' :
                         verdict === 'FALSE_POSITIVE' ? 'âœ…' :
                         verdict === 'BENIGN' ? 'ğŸŸ¢' : 'âš ï¸';

    const message = {
      text: `${verdictEmoji} Incident Report Generated`,
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: `${verdictEmoji} Incident Report: ${incidentId}`,
          },
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Verdict:*\n${verdict || 'N/A'}`,
            },
            {
              type: 'mrkdwn',
              text: `*Risk Score:*\n${riskScore ? `${riskScore}/100` : 'N/A'}`,
            },
          ],
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Report Path:*\n\`${reportPath}\``,
          },
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `Generated by Claude Code AI at ${new Date().toISOString()}`,
            },
          ],
        },
      ],
    };

    const response = await fetch(slackWebhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(message),
    });

    if (!response.ok) {
      console.error(`[Slack] âŒ Failed to send Slack notification: ${response.status}`);
      return;
    }

    console.log(`[Slack] âœ… Slack notification sent successfully`);

  } catch (error) {
    console.error(`[Slack] âŒ Slack error:`, error);
  }
}

/**
 * Discord ì•Œë¦¼ ì „ì†¡ (ì„ íƒì )
 */
export async function sendDiscordNotification(
  incidentId: string,
  reportPath: string,
  verdict?: string,
  riskScore?: number
): Promise<void> {
  try {
    const discordWebhookUrl = process.env.DISCORD_WEBHOOK_URL;

    if (!discordWebhookUrl) {
      return;
    }

    console.log(`[Discord] ğŸ“¢ Sending Discord notification...`);

    const verdictEmoji = verdict === 'TRUE_POSITIVE' ? 'ğŸš¨' :
                         verdict === 'FALSE_POSITIVE' ? 'âœ…' :
                         verdict === 'BENIGN' ? 'ğŸŸ¢' : 'âš ï¸';

    const embedColor = verdict === 'TRUE_POSITIVE' ? 0xef4444 :
                       verdict === 'FALSE_POSITIVE' ? 0x10b981 :
                       verdict === 'BENIGN' ? 0x10b981 : 0xfbbf24;

    const message = {
      embeds: [
        {
          title: `${verdictEmoji} Incident Report Generated`,
          description: `Incident ID: \`${incidentId}\``,
          color: embedColor,
          fields: [
            {
              name: 'Verdict',
              value: verdict || 'N/A',
              inline: true,
            },
            {
              name: 'Risk Score',
              value: riskScore ? `${riskScore}/100` : 'N/A',
              inline: true,
            },
            {
              name: 'Report Path',
              value: `\`${reportPath}\``,
              inline: false,
            },
          ],
          footer: {
            text: 'Generated by Claude Code AI',
          },
          timestamp: new Date().toISOString(),
        },
      ],
    };

    const response = await fetch(discordWebhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(message),
    });

    if (!response.ok) {
      console.error(`[Discord] âŒ Failed to send Discord notification: ${response.status}`);
      return;
    }

    console.log(`[Discord] âœ… Discord notification sent successfully`);

  } catch (error) {
    console.error(`[Discord] âŒ Discord error:`, error);
  }
}

/**
 * ëª¨ë“  ì•Œë¦¼ ì±„ë„ì— ì „ì†¡
 */
export async function sendAllNotifications(
  incidentId: string,
  reportPath: string,
  metadata: Partial<ReportMetadata>
): Promise<void> {
  await Promise.all([
    notifyReportGenerated({
      incident_id: incidentId,
      report_type: metadata.report_type || 'single',
      report_path: reportPath,
      risk_score: metadata.risk_score,
      verdict: metadata.verdict,
      generated_at: metadata.generated_at || new Date().toISOString(),
      generated_by: metadata.generated_by || 'claude-code',
      incident_count: metadata.incident_count || 1,
    }),
    sendSlackNotification(incidentId, reportPath, metadata.verdict, metadata.risk_score),
    sendDiscordNotification(incidentId, reportPath, metadata.verdict, metadata.risk_score),
  ]);
}
